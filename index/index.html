
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>Wiselab Android 1</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://storage.googleapis.com/claat-public/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
</head>
<link rel="stylesheet" href="css/style.css">
<body>
  <google-codelab-analytics gaid="UA-49880327-14"></google-codelab-analytics>
  <google-codelab codelab-gaid=""
                  id="index"
                  title="Wiselab Android 1"
                  environment="web"
                  feedback-link="">
    
      <google-codelab-step label="What you&#39;ll learn: overview" duration="0">
        <p class="image-container"><img style="width: 200.00px" src="img/d669aaa2bdd4e2f4.png"></p>
<p>Hello fellow developer! Welcome to <strong>Wisemen</strong>, we are happy to have you on board! We want to make sure you are soon up to speed with the core of Android development and our way of working. Therefore we created this awesome <strong>CodeLab</strong> for you. These are a constant work in progress, so please let us know if you have any feedback or suggestions! This is what you will learn in this CodeLab:</p>
<h2 is-upgraded>1. Creating a new project with our Android Core Library</h2>
<p>We have our own <strong>Android Core Library</strong> that we use in all our projects. This library contains a lot of useful classes and functions that we use in all our projects.</p>
<h2 is-upgraded>2. Folder structure</h2>
<p>We have a specific folder structure that we use in all our projects. This is to make sure that we can easily find all the files we need.</p>
<h2 is-upgraded>3. AGILE</h2>
<ol type="1">
<li>Work with <strong>Jira</strong></li>
<li>Using <strong>Github</strong> for version control</li>
<li>Branching strategy</li>
<li><strong>Pull Requests</strong></li>
</ol>
<h2 is-upgraded>4. Creating your first app</h2>
<p>You will be creating a simple To-Do app. This app will have a few features that are written out in Jira.</p>
<p>We are currently in a transition phase from <strong>XML</strong> to <strong>Jetpack Compose</strong>. Therefore we will be using <strong>Jetpack Compose</strong> for this app. Jetpack Compose is a new way of writing UI for Android apps in a more declarative way. You can find more information about Jetpack Compose <a href="https://developer.android.com/jetpack/compose" target="_blank">here</a>. Our Legacy projects are still written in XML, but as time comes you&#39;ll get to learn that as well! Our new projects are written in Jetpack Compose, therefore we will be using that for this Wiselab.</p>
<h2 is-upgraded>Let&#39;s get started!</h2>
<p class="image-container"><img src="img/9d981e73ce0028af.gif"></p>


      </google-codelab-step>
    
      <google-codelab-step label="What you need: Prerequisites" duration="0">
        <p>Before we start, make sure you have everything you need to complete this <strong>WiseLab</strong>. You will need:</p>
<h2 is-upgraded>Android Studio</h2>
<p>Download the IDE here if you don&#39;t have it already! <a href="https://developer.android.com/studio" target="_blank">Android Studio</a></p>
<h2 is-upgraded>Figma</h2>
<p>Our designers work with <strong>Figma</strong>. You can download it here:</p>
<ul>
<li><a href="https://www.figma.com/downloads/" target="_blank">Figma</a></li>
</ul>
<p>To access the designs you need to log in with your Wisemen account:</p>
<ul>
<li><a href="https://www.figma.com/file/hebgv4Qx8VanMAQkO1NFpa/Onboarding-to-do?node-id=407-4095&t=2qdyy89lKwN7dFw3-0" target="_blank">Figma wireframes</a></li>
</ul>
<h2 is-upgraded>GitHub Repository</h2>
<ul>
<li>You have to create your own repository on GitHub and add your personal reviewers to your project.</li>
</ul>
<h2 is-upgraded>Ticketing system</h2>
<p><em>ToDo: Add link to tickets</em></p>


      </google-codelab-step>
    
      <google-codelab-step label="Create the project" duration="0">
        <h2 is-upgraded>3.1 Create a new project</h2>
<p>Open Android Studio and create a new Compose project. You can name it Wiselab_Android_«Name».</p>
<p class="image-container"><img src="img/b8bab59ad5170185.png"></p>
<p>Make sure your package name is: **com.wiselab.wiselab_android_«name»**</p>
<p class="image-container"><img src="img/ebb9796df49a35f5.png"></p>
<h3 is-upgraded>Use the terminal or IDE to link your project to BitBucket</h3>
<p>We recommend to use a GIT GUI like <a href="https://www.sourcetreeapp.com/" target="_blank">SourceTree</a> or <a href="https://git-fork.com/" target="_blank">Fork</a>. As backup we will show you how to work with the <strong><em>terminal</em></strong>. If you prefer to work with the <strong><em>IDE</em></strong>, you can find the instructions <a href="https://www.jetbrains.com/help/idea/set-up-a-git-repository.html#add-remote" target="_blank">here</a>.</p>
<ul>
<li>Open the terminal in Android Studio (bottom left corner)</li>
<li>add remote origin to project</li>
<li><pre><code language="language-shell" class="language-shell">git init
git remote add origin &lt;your repo url&gt;
</code></pre>
</li>
</ul>
<p>From here on you can choose to use the terminal or the IDE to work with Git.</p>
<h2 is-upgraded>3.3 Our Branching strategy</h2>
<p>We use the <strong>Gitflow</strong> branching strategy. You can find more information about this strategy <a href="https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow" target="_blank">here</a>.</p>
<ul>
<li><strong>develop</strong> branch: this branch contains the latest development changes</li>
<li><strong>QA</strong> branch: this branch is used to test the features before they are merged into the staging branch</li>
<li><strong>staging</strong> branch: this branch is used send to the client for testing</li>
<li><strong>master</strong> branch: this branch contains the latest release of the app</li>
<li><strong>feature/...</strong> branches: these branches are used to develop new features for the upcoming release and are only pushed to develop</li>
<li><strong>bugfix/...</strong> branches: these branches are used to fix bugs in the app and are only pushed to develop</li>
</ul>
<p>Make sure you have created all 4 ‘standard&#39; branches. You can do this by either using the terminal, IDE or a GUI tool like <a href="https://www.sourcetreeapp.com/" target="_blank">SourceTree</a> or <a href="https://git-fork.com/" target="_blank">Fork</a>.</p>
<p>Now checkout the <strong>develop</strong> branch and create a new feature branch called <strong>feature/setup-project</strong>.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Add the Android Core Library" duration="0">
        <p>Now that you have created your project, it&#39;s time to add our <a href="https://github.com/appwise-labs/AndroidCore" target="_blank">Android Core Library</a>! This library contains a lot of useful classes and functions that we use in all our projects. The latest version is also noted in the readme.</p>
<h2 is-upgraded>4.1 Open the <strong>build.gradle</strong> file of your <strong>project</strong></h2>
<ul>
<li>Add the following <strong>plugins</strong> to the top of the file:</li>
<li>Be sure to check for the latest versions on the links above the plugins!</li>
<li>This is needed to use the Room dependency for our local database</li>
</ul>
<pre><code language="language-gradle.kts" class="language-gradle.kts">plugins {
    // https://mvnrepository.com/artifact/com.android.application/com.android.application.gradle.plugin?repo=google
    id(&#34;com.android.application&#34;) version &#34;&lt;&lt;version&gt;&gt;&#34; apply false
    
    // https://plugins.gradle.org/plugin/org.jetbrains.kotlin.android
    id(&#34;org.jetbrains.kotlin.android&#34;) version &#34;&lt;&lt;version&gt;&gt;&#34; apply false
    
    //https://github.com/google/ksp/releases
    id(&#34;com.google.devtools.ksp&#34;) version &#34;&lt;&lt;version&gt;&gt;&#34; apply false
}
</code></pre>
<h2 is-upgraded>4.2 Open the <strong>settings.gradle</strong> file of your <strong>project</strong></h2>
<ul>
<li>Under the <strong>repositories</strong> tag in the <strong>dependencyResolutionManagement</strong> block, add the following:</li>
</ul>
<pre><code language="language-gradle.kts" class="language-gradle.kts">repositories {
    google()
    mavenCentral()
    
    maven(&#34;maven.google.com&#34;)
    maven(&#34;https://maven.fabric.io/public&#34;)
    maven(&#34;https://jitpack.io&#34;)
    maven(&#34;https://plugins.gradle.org/m2/&#34;)
}
</code></pre>
<h2 is-upgraded>4.3 Open the <strong>build.gradle</strong> file of your <strong>app</strong></h2>
<ul>
<li>Make sure you have following <strong>plugins</strong></li>
</ul>
<pre><code language="language-gradle.kts" class="language-gradle.kts">plugins {
    id(&#34;com.android.application&#34;)
    id(&#34;org.jetbrains.kotlin.android&#34;)
    id(&#34;com.google.devtools.ksp&#34;)
}
</code></pre>
<ul>
<li>Add the following <strong>dependencies</strong>. The versions can be found in the url above the dependencies.</li>
</ul>
<pre><code language="language-gradle" class="language-gradle">    //Appwise core dependencies
    //https://jitpack.io/#appwise-labs/AndroidCore
    implementation(&#34;com.github.appwise-labs.AndroidCore:core:&lt;&lt;version&gt;&gt;&#34;)
    implementation(&#34;com.github.appwise-labs.AndroidCore:room:&lt;&lt;version&gt;&gt;&#34;)
    implementation(&#34;com.github.appwise-labs.AndroidCore:networking:&lt;&lt;version&gt;&gt;&#34;)

    //Room
    //https://developer.android.com/jetpack/androidx/releases/room
    implementation(&#34;androidx.room:room-runtime:&lt;&lt;version&gt;&gt;&#34;)
    ksp(&#34;androidx.room:room-compiler:&lt;&lt;version&gt;&gt;&#34;)
    
    //Koin for dependency injection
    //https://insert-koin.io/docs/setup/koin/
    implementation(&#34;io.insert-koin:koin-core:&lt;&lt;version&gt;&gt;&#34;)
    implementation(&#34;io.insert-koin:koin-android:&lt;&lt;version&gt;&gt;&#34;)
    implementation(&#34;io.insert-koin:koin-androidx-compose:&lt;&lt;version&gt;&gt;&#34;)
    
    //Compose navigation
    //https://github.com/raamcosta/compose-destinations
    implementation(&#34;io.github.raamcosta.compose-destinations:animations-core:&lt;&lt;version&gt;&gt;&#34;)
    ksp(&#34;io.github.raamcosta.compose-destinations:ksp:&lt;&lt;version&gt;&gt;&#34;)
</code></pre>
<p>Now you can sync your project and you&#39;re ready to go! 🚀 If you have any more questions about the Android Core Library, you can find more information on the link above.</p>
<p>Don&#39;t forget to push these changes to your <strong>feature/setup-project</strong> branch with a clear commit message.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Setup Project" duration="0">
        <p>It&#39;s time to set some last few things before we can start coding!</p>
<p>In case you forgot: <a href="https://www.figma.com/file/hebgv4Qx8VanMAQkO1NFpa/Onboarding-to-do?node-id=407-4095&t=2qdyy89lKwN7dFw3-0" target="_blank">Figma wireframes</a></p>
<h2 is-upgraded>5.1 App class</h2>
<p>Let&#39;s start by creating the <strong>App</strong> class. This is the first class that is called when the app starts. We will use this class to set up our dependency injection and navigation in the future. Create a new class in the main package called <strong>App</strong> and add the following code:</p>
<pre><code language="language-kotlin" class="language-kotlin">class App : Application() {

    companion object {
        lateinit var instance: App
            private set

        fun isProxymanEnabled() = BuildConfig.DEBUG &amp;&amp; BuildConfig.BUILD_TYPE != &#34;release&#34;
    }

    override fun onCreate() {
        super.onCreate()

        instance = this
    }
}
</code></pre>
<p>Let&#39;s explain this bit of code. The <strong>App</strong> class extends the <strong>Application</strong> class. This is the first class that is called when the app starts. We use the <strong>companion object</strong> to create a singleton of the <strong>App</strong> class. This way we can access the <strong>App</strong> class from anywhere in the app. We also use this class to check if we are in debug mode and if we are not in release mode. This is used to enable the Proxyman interceptor for debugging purposes. The instance of the <strong>App</strong> class is set in the <strong>onCreate</strong> function.</p>
<h3 is-upgraded>5.1.1 Init Core</h3>
<ul>
<li>Create a new private function called initCore to set up the Android Core Library. This function will be called in the <strong>onCreate</strong> function.</li>
<li>Add the following code to the <strong>initCore</strong> function:</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">CoreApp.init(this)
    .apply {
        if (BuildConfig.DEBUG) {
            initializeErrorActivity(true)
        }
    }
    .initializeLogger(getString(R.string.app_name), BuildConfig.DEBUG)
    .build()
</code></pre>
<p>This code initializes the Android Core Library. We also initialize the error activity and the logger. The logger is used to log messages to the console. The error activity is used to show errors in the app. This is only enabled in debug mode.</p>
<ul>
<li>Don&#39;t forget to add the <strong>initCore</strong> function to the <strong>onCreate</strong> function.</li>
</ul>
<h3 is-upgraded>5.1.2 Init Koin</h3>
<p><a href="https://github.com/InsertKoinIO/koin" target="_blank">Koin</a> is our <a href="https://developer.android.com/training/dependency-injection" target="_blank">dependency injection</a> library. We use this library to inject our viewmodels and repositories in our composables. This way we can easily test our code.</p>
<p>Create a new package called <strong>com.wiselab.«name».data.di</strong>. This is where we will put all our dependency injection related classes.</p>
<ul>
<li>Create a new file called <strong>AppModule</strong> with following code:</li>
<li>We will add to this in the future when we need to inject more dependencies.</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">val appModule = module { }
</code></pre>
<p>Here we create a module that will be used to inject our dependencies. We create a single instance of our database here.</p>
<ul>
<li>In the <strong>App</strong> class: create a new private function called initKoin to set up Koin. This function will be called in the <strong>onCreate</strong> function.</li>
<li>Add the following code to the <strong>initKoin</strong> function:</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">startKoin {
  androidLogger(Level.DEBUG)
  //this is so when you want to inject app context this determines where to get it
  androidContext(this@App)
  modules(appModule)
}
</code></pre>
<p>Here we initialize Koin and add the appModule we created earlier.</p>
<h2 is-upgraded>5.2 Theme</h2>
<ul>
<li>Go to the figma file under the colors tab and place the colors in the <strong>Color.kt</strong> file in the theme package. Place these colors in an <strong>Object</strong>.</li>
<li>Change the colors of the <strong>LightColorScheme</strong> in the theme.kt file, delete the <strong>DarkColorScheme</strong> because we are not going to implement a dark theme.</li>
<li>Check the <a href="https://m3.material.io/styles/color/the-color-system/key-colors-tones" target="_blank">Material3</a> guidelines for the key colors and Color roles.</li>
<li>Change the <strong>Theme</strong>-function to the most basic version like this:</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">   @Composable
fun AppTheme(
   content: @Composable () -&gt; Unit
) {
   val colors = LightColorScheme

   MaterialTheme(
       colorScheme = colors,
       content = content
   )
}
</code></pre>
<h2 is-upgraded>5.3 TextStyles</h2>
<ul>
<li>Add an <strong>object</strong>-file named <strong>TextStyles</strong> to preset our different text styles. 🔤</li>
<li>Use the <a href="https://www.figma.com/file/zTqTMDTcAQksdHoGxZwPRG/Project-Template?type=design&node-id=747%3A5124&mode=design&t=pYCysiA5rLg22jDL-1" target="_blank">Design</a> guidelines for the different text styles.</li>
<li>Let&#39;s create the first style together: Look at the figma design for the largest headline: &#34;Mijn to do&#39;s&#34;. Click on it until it is the only component selected. You can see the text style in the right panel. Use these values to create the <strong>HeadlineLarge</strong> style:</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">object TextStyles {

    val headlineLarge = TextStyle(
        fontSize = 34.sp,
        fontWeight = FontWeight.W700,
        lineHeight = 41.sp,
        letterSpacing = 0.37.sp
    )
}
</code></pre>
<ul>
<li>Note that we use the <strong>Sp</strong> unit for the font size, line height and letter spacing. This is because we want to use the <strong>Sp</strong> unit for all our text styles. This way the text will scale with the system font size. Don&#39;t mind the fontFamily, SF Pro Display is the default font on iOS. The color is not needed because we will set the color in the theme.</li>
</ul>
<h2 is-upgraded>5.4 Spacing</h2>
<ul>
<li>Add an <strong>object</strong>-file named <strong>Spacing</strong> to preset our different spacing values. 📏</li>
<li>Use the <a href="https://m3.material.io/layout/spacing" target="_blank">Material3</a> guidelines for the different spacing values.</li>
<li>Use this as a reference for the different spacing values:</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">package com.wiselab.onboarding_compose.ui.theme

import androidx.compose.material3.MaterialTheme
import androidx.compose.runtime.Composable
import androidx.compose.runtime.ReadOnlyComposable
import androidx.compose.runtime.compositionLocalOf
import androidx.compose.ui.unit.Dp
import androidx.compose.ui.unit.dp

object Spacing {
    val default: Dp = 0.dp
    val extraSmall: Dp = 4.dp
    val small: Dp = 8.dp
    val medium: Dp = 16.dp
    val large: Dp = 24.dp
    val extraLarge: Dp = 40.dp
    val huge: Dp = 64.dp
}
</code></pre>
<h2 is-upgraded>5.5 add your application name to the manifest</h2>
<p>In the <strong>AndroidManifest</strong> file add a new line in the <strong>application</strong> tag: <code>android:name=".App"</code></p>
<h2 is-upgraded>5.5 Check your first preview</h2>
<ul>
<li>Go to the <strong>MainActivity.kt</strong> file and check for errors.</li>
<li>Change the previous theme name to the new <strong>AppTheme</strong> name and clear the imports</li>
</ul>
<h2 is-upgraded>5.5.1 Add a virtual or physical device</h2>
<p>If you don&#39;t have a virtual or physical device, you can create one by following these steps: 📱</p>
<p><strong>Physical device</strong></p>
<ul>
<li>Go to your phone settings and enable <strong>Developer options</strong>. If you don&#39;t know how to do this, you can find more information <a href="https://developer.android.com/studio/debug/dev-options" target="_blank">here</a>.</li>
<li>Connect you phone to your computer with either USB or Wireless debugging. You can find more information <a href="https://developer.android.com/tools/adb#connect-to-a-device-over-wi-fi" target="_blank">here</a>.</li>
</ul>
<p><strong>Virtual device</strong></p>
<ul>
<li>Go to the <strong>AVD Manager</strong> in Android Studio and create a new virtual device. You can find more information <a href="https://developer.android.com/studio/run/managing-avds" target="_blank">here</a>.</li>
</ul>
<h2 is-upgraded>5.3.2 Run the preview</h2>
<p>In the <strong>MainActivity.kt</strong> file, click on the <strong>Preview</strong> button next to the <strong>GreetingPreview</strong> function. This will open a preview of your app in the IDE. If you have a virtual or physical device connected, you can also run the app on your device.</p>
<p class="image-container"><img src="img/f4a589373a570440.png"></p>
<p>Now you can push your changes to your <strong>feature/setup-project</strong> branch with a clear commit message and create a pull request to merge your branch into the <strong>develop</strong> branch. Don&#39;t forget to add your buddy as a reviewer! 🕵️</p>


      </google-codelab-step>
    
      <google-codelab-step label="Agile" duration="0">
        <p>We want to work as efficient as possible. Therefore we use the Agile way of working. We created our custom <a href="https://theagilebible.com" target="_blank">Agile Bible</a> where we describe how we work the Agile way.</p>
<h2 is-upgraded>6.1 Agile Bible</h2>
<p>The Agile Bible contains all the information you need to know about how we work the Agile way. (Work in Progress) Take your time to read it and ask questions if you have any.</p>
<p>Some key subjects:</p>
<ul>
<li>The Agile Manifesto</li>
<li>Scrum Cycles</li>
<li>User Stories</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Create your first components and screen" duration="0">
        <p>Start creating some UI components and a screen to show them on. Starting with the <a href="https://www.figma.com/file/hebgv4Qx8VanMAQkO1NFpa/Onboarding-to-do?type=design&node-id=455-5009&mode=design&t=a3AEuYp0dvS3MRfT-4" target="_blank">landing screen</a> where we can register or log in. We always name our branches to the Jira ticket. The first ticket we will work on is <strong>OB-1</strong>. Create a new branch called <code>feature/ob-1--landing-screen</code></p>
<ul>
<li>Drag the Jira ticket to the <strong>In Development</strong> column.</li>
</ul>
<h2 is-upgraded>7.1 Create some buttons</h2>
<ul>
<li>Open the figma file and check the <strong>components used</strong> page. This is where you can find all the <a href="https://www.figma.com/file/hebgv4Qx8VanMAQkO1NFpa/Onboarding-to-do?type=design&node-id=877-1328&mode=dev" target="_blank">components used</a> in the design.</li>
<li>Create a new package called <strong>shared</strong>. The full path should be  <strong>com.wiselab.«name».ui.shared</strong>.</li>
<li>Create a new Kotlin file named <strong>Buttons</strong> in the <strong>Shared</strong> package to create our different buttons</li>
<li>Create the following buttons: <ul>
<li>PrimaryButton</li>
<li>SecondaryButton</li>
<li>TertiaryButton</li>
<li>OutlinedButton</li>
</ul>
</li>
<li>Show a preview of the buttons like this:</li>
</ul>
<p class="image-container"><img style="width: 400.00px" src="img/f0292cc02a71b62b.png"></p>
<p>Note that you can see the preview when clicking on the <img style="width: 50.00px" src="img/23a4c9d582f85e7f.png"> button in the top right corner of the IDE.</p>
<ul>
<li>Here&#39;s a bit of code to get you going:</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">@Preview
@Composable
fun ButtonsPreview() {
    AppTheme {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .background(MaterialTheme.colorScheme.background)
                .padding(Spacing.medium),
            verticalArrangement = Arrangement.spacedBy(Spacing.medium)
        ) {
            Buttons.Primary(
                text = &#34;Primary&#34;,
                Modifier.fillMaxWidth()
            ) {}
        }
    }
}

object Buttons {

    @Composable
    fun Primary(
        text: String,
        modifier: Modifier = Modifier,
        onClick: () -&gt; Unit
    ) {
        Button(
            modifier = modifier,
            shape = RoundedCornerShape(5.dp),
            colors = ButtonDefaults.buttonColors(
                containerColor = Color.PeriWinkel,
                contentColor = Color.Black
            ),
            onClick = onClick
        ) {
            Text(text = text)
        }
    }
}
</code></pre>
<ul>
<li>Let&#39;s explain what&#39;s going on here:</li>
</ul>
<p>first off we create the object Buttons. This is a container for all our buttons. We do this so we can easily find all our buttons in the project. Then we create a composable function for each button. This way we can easily reuse the buttons in our project. The Primary Button has 3 parameters:</p>
<ul>
<li>text: String</li>
<li>modifier: Modifier</li>
<li>onClick: () -&gt; Unit</li>
</ul>
<p>The text and onClick parameters speak for themselves. The modifier is a bit more complicated. It&#39;s a way to add styling to our button like positioning, padding etc..., but more about this later.</p>
<ul>
<li>Next the <strong>preview</strong> is created, we always place these above the object:</li>
</ul>
<p>Make sure to check the modifiers we use here. The <code>fillMaxWidth</code> modifier makes sure the button takes up the full width of the screen. The <code>background</code> modifier makes sure the background color is the same as the background color of the app. The <code>padding</code> modifier makes sure there is some space between the buttons. The <code>verticalArrangement</code> makes sure the buttons are spaced out vertically.</p>
<ul>
<li>Now create the other buttons and show them in the preview.</li>
<li>Hint for the disabled state: Check the opacity/alpha value in Figma and use <code>Color.SanJuan.copy(alpha = ...)</code>.</li>
<li>Commits linked to Jira tickets should always contain the ticket number. In this case <strong>OB-1</strong>. The commit message should look something like this: <strong>OB-1: Create button components</strong>.</li>
</ul>
<h2 is-upgraded>7.2 Create a screen</h2>
<p>The task manager is seen as 2 Epics, onboarding and todo&#39;s. create a new package <strong>com.wiselab.«name».feature</strong>. Also create a new package called <strong>onboarding</strong> in the <strong>feature</strong> package. The full path should be <strong>com.wiselab.«name».feature.onboarding</strong>. In this package create a new package called <strong>landing</strong> for the landing screen. The full path should be <strong>com.wiselab.«name».feature.onboarding.landing</strong>.</p>
<ul>
<li>Create a new Kotlin file called <strong>LandingScreen</strong> in the <strong>landing</strong> package.</li>
<li>We like to split up our screens in minimal 3 parts, we go in more detail about this in a future section. For now<ul>
<li><strong>Layout</strong>: this is where we place all the content of the screen</li>
<li><strong>Screen</strong>: this is where we link our data and state to the layout</li>
<li><strong>Preview</strong>: this is where we show the layout in a preview</li>
</ul>
</li>
<li>This is also the order we create them in. Note that this is <strong>not</strong> the order in the file. We <strong>always place the preview above the screen and the screen above the layout</strong>.</li>
<li>This is the preview we are working towards:</li>
</ul>
<p class="image-container"><img style="width: 400.00px" src="img/dc4b0772e8520b03.png"></p>
<h3 is-upgraded>7.2.1 Create the Layout</h3>
<ul>
<li>Create a composable function called <strong>LandingLayout</strong>. This is where we place all the content of the screen.</li>
<li>Because there are 2 buttons vertically aligned we will be using the <strong>Column</strong> Composable as previously explained.</li>
<li>The function will look something like this:</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">@Composable
fun LandingLayout() {
    Scaffold {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .wrapContentHeight()
                .padding(horizontal = Spacing.medium)
        ) {
            Buttons.Primary(text = &#34;Create an account&#34;, Modifier.fillMaxWidth()) {}
            Buttons.Secondary(
                text = &#34;Log in&#34;,
                Modifier
                    .fillMaxWidth()
                    .padding(bottom = 58.dp)
            ) {}
        }
    }
}
</code></pre>
<p>We use the <strong>fillMaxWidth</strong> modifier to make sure the buttons take up the full width of the screen. We use the <strong>wrapContentHeight</strong> modifier to make sure the column is only as high as it&#39;s content. We use the <strong>padding</strong> modifier to add some space between the buttons and the edge of the screen. and padding under the secondary button.</p>
<p>Some explanation about <strong>Scaffold</strong> : The <strong>Scaffold</strong> is a Composable that implements the basic material design visual layout. It has a top bar, bottom bar and a floating action button. We will be using this a lot in our projects. It is like a structured container for our screen. At This moment the Scaffold is still experimental, that&#39;s why we need to add the <code>@OptIn(ExperimentalMaterial3Api::class)</code></p>
<h3 is-upgraded>7.2.2 Scaffold Padding</h3>
<ul>
<li>There is still an issue. The Scaffold must always pass a padding value to it&#39;s content. This is because the Scaffold has a top bar, bottom bar and a floating action button. We need to make sure the content is not hidden behind these.</li>
<li>We can fix it like this:</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">@Composable
fun LandingLayout() {
    Scaffold { contentPadding -&gt;
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .wrapContentHeight()
                .padding(contentPadding)
                .padding(horizontal = Spacing.medium)
        ) {
            Buttons.Primary(text = &#34;Create an account&#34;, Modifier.fillMaxWidth()) {}
            Buttons.Secondary(
                text = &#34;Log in&#34;,
                Modifier
                    .fillMaxWidth()
                    .padding(bottom = 58.dp)
            ) {}
        }
    }
}
</code></pre>
<p>Note that the Scaffold padding is always the first padding that is applied. A modifier is always applied from <strong>top to bottom</strong>.</p>
<h3 is-upgraded>7.2.3 Create the screen</h3>
<ul>
<li>Now create the <strong>LandingScreen</strong> composable. This is where we place the layout in a screen, this is the parent.</li>
<li>Here is where we will link our data to our view. We will explain this in a future section.</li>
<li>For now we will just call our LandingLayout function.</li>
<li>The function will look something like this:</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun LandingScreen() {
    LandingLayout()
}

</code></pre>
<h3 is-upgraded>7.2.4 Create the preview</h3>
<ul>
<li>Now create the <strong>LandingScreenPreview</strong> composable. This is where we show the screen in a preview. If you forgot how to create a preview, check the <strong>ButtonsPreview</strong>.</li>
<li>As you will see the buttons are not yet aligned at the bottom. We can fix this by adding a <strong>Spacer</strong> above the buttons like this:</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">@Composable
fun LandingLayout() {
    Scaffold { contentPadding -&gt;
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .wrapContentHeight()
                .padding(contentPadding)
                .padding(horizontal = Spacing.medium)
        ) {
            Spacer(modifier = Modifier.weight(1f))
            Buttons.Primary(text = &#34;Create an account&#34;, Modifier.fillMaxWidth()) {}
            Buttons.Secondary(
                text = &#34;Log in&#34;,
                Modifier
                    .fillMaxWidth()
                    .padding(bottom = 58.dp)
            ) {}
        }
    }
}
</code></pre>
<p>The spacer will take up all the available space and push the buttons to the bottom. The <a href="https://developer.android.com/jetpack/compose/modifiers#weight-in-row-and-column" target="_blank">** weight** modifier</a> is used to make sure the spacer takes up all the available space.</p>
<h3 is-upgraded>7.2.5 String extraction</h3>
<ul>
<li>There is still 1 bad practise. Strings should never be hardcoded. We should always use a string resource. We can fix this by adding a string resource to the <strong>strings.xml</strong> file. The easiest way to do this is to right click on the string and select <strong>Show Context Actions</strong> and then <strong>Extract string resource</strong>. Do this for both buttons.</li>
<li>Use command + click (or windows + click) on the string to navigate to the string resources. Here you can change, add, delete and even translate strings.</li>
<li>Don&#39;t forget to commit your changes with a proper commit message!</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Navigation" duration="0">
        <p>Let&#39;s add navigation to our app. We will use the <a href="https://github.com/raamcosta/compose-destinations" target="_blank">raamcosta compose destinations library</a> for this. This library is a wrapper around the navigation component. It makes it easier to use the navigation component with compose. It also adds some nice features like <strong>animations</strong> and <strong>deep linking</strong>. We already added the dependency in the setup of the project.</p>
<h2 is-upgraded>8.1 Setup navigation</h2>
<ul>
<li>Create a new package called <strong>navigation</strong> in the <strong>onboarding</strong> package like this: <strong>com.wiselab.«name».onboarding.navigation</strong></li>
<li>Make a new file called <strong>OnboardingNavGraph</strong> in the <strong>navigation</strong> package.</li>
<li>Add following code to the file:</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">import com.ramcosta.composedestinations.annotation.NavGraph
import com.ramcosta.composedestinations.annotation.RootNavGraph

@RootNavGraph(start = true)
@NavGraph
annotation class OnboardingNavGraph(
    val start: Boolean = false
)
</code></pre>
<ul>
<li>This is a <strong>NavGraph</strong>. It&#39;s a class that contains all the destinations of a navigation graph. The <strong>@RootNavGraph</strong> annotation tells the library that this is the root of the navigation graph. The <strong>@NavGraph</strong> annotation tells the library that this is a navigation graph. The <strong>start</strong> parameter tells the library that this is the start of the navigation graph. This means that this is the first screen that will be shown when the app starts.</li>
<li>Open the <strong>LandingScreen</strong> file and add the 2 <strong>annotations</strong> to the <strong>LandingScreen</strong> composable function: <code>@Destination</code> and <code>@OnboardingNavGraph(start = true)</code></li>
<li>The <strong>@Destination</strong> annotation tells the library that this is a destination. The <strong>@OnboardingNavGraph(start = true)</strong> annotation tells the library that this is the start of the navigation graph. This means that this is the first screen that will be shown when the app starts.</li>
</ul>
<h2 is-upgraded>8.2 Integrate in the MainActivity</h2>
<ul>
<li>Open the <strong>MainActivity</strong> file and remove the <strong>Greeting</strong> composable function with it&#39;s preview.</li>
<li>Change the class so it looks like this:</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">class MainActivity : ComponentActivity() {
    @OptIn(ExperimentalMaterial3Api::class)
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            AppTheme {
                val navController = rememberNavController()

                Scaffold { paddingValues -&gt;
                    Box(
                        modifier = Modifier
                            .fillMaxSize()
                            .background(MaterialTheme.colorScheme.background)
                            .padding(paddingValues)
                    ) {
                        DestinationsNavHost(
                            navGraph = NavGraphs.onboarding,
                            navController = navController
                        )
                    }
                }
            }
        }
    }
}
</code></pre>
<ul>
<li>We use the <strong>Scaffold</strong> composable to create a basic material design visual layout. We will be using this a lot in our projects.</li>
<li>The Box composable is a container that can contain multiple composable functions. We use it to place the <strong>DestinationsNavHost</strong> composable in it.</li>
<li>The <strong>DestinationsNavHost</strong> composable is a composable function from the destinations library. It&#39;s a wrapper around the navigation component. It takes a <strong>navGraph</strong> and a <strong>navController</strong> as parameters. The <strong>navGraph</strong> is the navigation graph we created in the previous step. The <strong>navController</strong> is a controller that controls the navigation between the screens. We will use this later to navigate between screens.</li>
</ul>
<h2 is-upgraded>8.3 Run your app</h2>
<p>In the top right of your IDE you can select the device you want to run your app on. Select a device and run the app configuration. If you can&#39;t find it, try clicking the arrow down to see all configurations like this:</p>
<p class="image-container"><img alt="Run configuration" src="img/ea5b86c9c2e2d49f.png"></p>
<p>You should see the landing screen now! 🙌🏻 Don&#39;t forget to commit an push your changes with a proper commit message including the ticket number!</p>
<h2 is-upgraded>8.4 Time for a PR</h2>
<ul>
<li>Create a pull request from your feature branch to the develop branch.</li>
<li>Add your buddy as a reviewer.</li>
<li>Drag your ticket in Jira from <strong>In Development</strong> to <strong>Pull Request</strong>. 🚀</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Working with states" duration="0">
        <p>Now that you know how to make your first screen, we can start working with states. To work with states we first need to understand how Composable functions work.</p>
<h2 is-upgraded>9.1 Composition and recomposition</h2>
<p>A basic <strong>Composable function</strong> with no parameters will never change how it is drawn. This implies that the view is never redrawn, unless the parent Composable function is redrawn. When a Composable function is redrawn, it is called <strong>recomposition</strong>. One way to trigger recomposition is triggered is when a Composable function is called with different parameters. For instance if we have a Composable function that takes a String as a parameter, and we call it with the String &#34;Hello World&#34;, and then we call it again with the String &#34;Hello Wisemen&#34;, the Composable function will be recomposed. If we want to trigger recomposition without changing the parameters, to add increased functionality, we need to use <strong>state</strong>.</p>
<h2 is-upgraded>9.2 State</h2>
<p>A State is a way to <strong>store data</strong> in a Composable function. When the state changes, the Composable function is recomposed. A basic way to create a state is:</p>
<pre><code language="language-kotlin" class="language-kotlin">var state by remember { mutableStateOf(&#34;Hello World&#34;) }
</code></pre>
<p>Here we created a state that holds a String. The state is initialized with the value &#34;Hello World&#34;. The state is <strong>mutable</strong>, which triggers recomposition of the views using this value as parameter. The <strong>remember</strong> function is used to make sure the state is not recreated every time the Composable function is recomposed. This is important because if the state is recreated, the value is reset to the initial value.</p>
<h2 is-upgraded>9.3 TextField</h2>
<p>The best way to learn how to work with states is to work with a <code>TextField</code>. Like we did for the buttons, we will create a new file called ** EditText.kt**. Here you can create your basic edit texts that can be reused in the future. Create a basic EditText like this:</p>
<pre><code language="language-kotlin" class="language-kotlin">@Composable
fun EditText(
    modifier: Modifier = Modifier
) {
    var input = &#34;&#34;

    TextField(
        value = input,
        onValueChange = { input = it },
        modifier = modifier
    )
}
</code></pre>
<p>When you run this preview and try to type in this textField, you see that nothing happens. This is because the parameters of the EditText are never changed and the composable function is not smart enough to know that the input variable is changed. To fix this we need to use state. Change the EditText to this:</p>
<pre><code language="language-kotlin" class="language-kotlin">@Composable
fun EditText(
    modifier: Modifier = Modifier
) {
    var input by remember { mutableStateOf(&#34;&#34;) }

    TextField(
        value = input,
        onValueChange = { input = it },
        modifier = modifier
    )
}
</code></pre>
<p>Now when you run the preview and type in the TextField, you see that the text is updated. This is because the state is changed and the Composable function is recomposed. <strong>IT LIVES</strong> 🎉</p>
<h2 is-upgraded>9.4 Stateless first and state hoisting</h2>
<p>When working with states, it is important to keep your Composable functions stateless as much as possible. As mentioned earlier, a Composable function is recomposed when the state changes. If your UI gets more complex, and you use more function hierarchies with all their different states, it can become hard to keep track of all the states. And also it can lead to <strong>unwanted recompositions</strong> an because of that a <strong>bad performance</strong>. This also breaks the &#34;single source of responsibility&#34; principle which can lead to bug-prone code. To prevent this, we can use state hoisting. State hoisting is a way to move the state to the parent Composable function.</p>
<p>Let&#39;s improve our EditText with state hoisting so it follows this principle.</p>
<pre><code language="language-kotlin" class="language-kotlin">@Composable
fun EditText(
    modifier: Modifier = Modifier,
    input: String,
    onInputChanged: (String) -&gt; Unit
) {
    TextField(
        value = input,
        onValueChange = onInputChanged,
        modifier = modifier
    )
}


@Composable
fun ComposableUsingEditText() {
    var input by remember { mutableStateOf(&#34;&#34;) }

    EditText(
        input = input,
        onInputChanged = { input = it }
    )
}
</code></pre>
<p>Now the EditText is stateless and the state is hoisted to the parent Composable function. If you do this for all your Composable functions, you will have a better performance and bugs will be easier to find.</p>
<h2 is-upgraded>9.5. Exercise: Finishing the component library</h2>
<p>Now that you know how to style your Composables and how to work with states, you can finish the component library.</p>
<p>Keep these principles in mind:</p>
<ul>
<li>Make sure to create a new file for every type of component you create. This way you can reuse them in the future and you don&#39;t have to restyle them every time.</li>
<li>Remember to add the modifier parameter to your custom views so they are easier to lay out in the future.</li>
<li>Make sure to use state hoisting when working with states.</li>
<li>Use previews to test your components handling of different states.</li>
</ul>
<p>After you are finished, make a new PR and ask your buddy to review it. 🚀</p>


      </google-codelab-step>
    
      <google-codelab-step label="MVVM and screen structure" duration="0">
        <p>Before we start building our screens, we need to understand how we structure our screens and how we use <strong>MVVM</strong>. More complex screens that need to fetch data from the backend or database and manipulate it, need to be structured in a way that is easy to understand and maintain.</p>
<h2 is-upgraded>10.1 MVVM</h2>
<p>MVVM stands for <strong>Model-View-ViewModel</strong>. It consists of three parts:</p>
<ul>
<li><strong>Model</strong>: The data model that is used in the screen. For this we use repositories as a data source. More on this later when we start with networking.</li>
<li><strong>View</strong>: The UI of the screen. This is the Composable function that is used to draw the screen. This you know already.</li>
<li><strong>ViewModel</strong>: The logic of the screen. This is the class that holds the logic of the screen. It can be used to fetch data from the backend or database, manipulate the data and pass it to the view.</li>
</ul>
<h2 is-upgraded>10.2 ViewModel</h2>
<p>As mentioned above, this is the class that holds the <strong>logic</strong> of the screen. Since we want to keep the <strong>data manipulation and the UI separate</strong>, we have some rules for the communication between the ViewModel and the View.</p>
<ul>
<li>The ViewModel should never know about the View. This means that the ViewModel should not have any references to the View.</li>
<li>Any data that needs to be manipulated should be managed here, not in the View.</li>
<li>The data that is passed to the View should be <strong>immutable</strong>. This means that the View should not be able to change the data.</li>
<li>If the data needs to be changed, it should be done in the ViewModel.</li>
</ul>
<h2 is-upgraded>10.3 Screen structure</h2>
<p>Lets look at the image below to see the whole picture of the communication between the View and the ViewModel.</p>
<p class="image-container"><img src="img/2176bbf0e51fe0ea.png"></p>
<p>We know, the whole picture is a little overwhelming. But don&#39;t worry, we will go through it step by step.</p>
<p>For naming, keep in mind, all these classes work in tandem to create a screen. So we will name them after the screen they are used in. For instance if we create a login screen, we will have a LoginScreen, LoginViewModel, LoginUiState, LoginActions and so on.</p>
<h3 is-upgraded>10.3.1 Screen.kt (View)</h3>
<p>Here we have the View layer of our screen. This consist of at least 3 composable functions with their own responsibilities: Screen, Layout and Preview</p>
<pre><code language="language-kotlin" class="language-kotlin">@Composable
fun Screen(
    navController: NavController,
    viewModel: ViewModel = koinViewModel()
) {
    // Collect data from the ViewModel to populate the layout
    val uiState by viewModel.uiState.collectAsState()

    // Establish links between UI events and the navController
    LaunchedEffect(viewModel) {
        viewModel.eventFlow.collect { event: UiEvent -&gt;
            when (event) {
                is UiEvent.NavigateToNext -&gt; navController.navigate(NextDestination)
                is UiEvent.ShowDialog -&gt; // show dialog
            }
        }
    }

    // Link the uiState and action handler to the layout
    Layout(
        state = uiState,
        onAction = viewModel::onAction,
    )
}
</code></pre>
<p>The <code>Screen</code> function is a crucial part of your UI layer (View) in Jetpack Compose. It serves as the entry point for rendering your screen&#39;s content. Here are the key aspects of this function:</p>
<ul>
<li>Parameters <ul>
<li><code>NavController</code>: The navigation controller used for navigating between screens.</li>
<li><code>ViewModel</code>: An instance of the ViewModel associated with this screen. We use the <a href="https://developer.android.com/training/dependency-injection" target="_blank">dependency injection</a> library Koin to inject the ViewModel.</li>
</ul>
</li>
<li>Function <ul>
<li>Collects data from the ViewModel to populate the layout.</li>
<li>Establishes links between UI events and the <code>navController</code>.</li>
<li>Links actions of the ViewModel to the layout components.</li>
</ul>
</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">@Composable
fun Layout(
    state: UiState,
    onAction: (Action) -&gt; Unit
) {
    // Layout components
}
</code></pre>
<p>The <code>Layout</code> function is responsible for defining the structure of your screen&#39;s layout. It plays a central role in rendering the UI. Here&#39;s what you need to know about it:</p>
<ul>
<li>Parameters <ul>
<li><code>state: UiState</code>: Represents the current state of the screen&#39;s UI.</li>
<li><code>onAction: (Action) -> Unit</code>: A function used to handle UI actions.</li>
</ul>
</li>
<li>Function <ul>
<li>Displays the UI components based on the provided <code>state</code>.</li>
<li>Triggers actions based on user interactions.</li>
<li>Also used for preview and testing purposes.</li>
</ul>
</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">@Preview
@Composable
fun Preview() {
    AppTheme {
        Layout(
            state = UiState(),
            onAction = {}
        )
    }
}
</code></pre>
<p>The <code>Preview</code> function provides a simple, placeholder implementation of the <code>Layout</code> with a default state. It&#39;s useful for previewing your layout during development.</p>
<h3 is-upgraded>10.3.2 ViewModel.kt (ViewModel)</h3>
<p>The <code>ViewModel</code> class is a critical component in managing the state and behavior of your UI.</p>
<pre><code language="language-kotlin" class="language-kotlin">class ViewModel(
    private val repository: Repository,
    savedStateHandle: SavedStateHandle
) : ViewModel() {

    // Extracts navigation arguments from the SavedStateHandle to receive data from the previous screen
    private val args = savedStateHandle.navArgs&lt;NavArgs&gt;()

    // The single source of the truth for the UI state
    var state by mutableStateOf(UiState())
        // The setter is private to prevent external modification
        private set

    // A channel for sending events to the UI
    private val eventChannel = Channel&lt;UiEvent&gt;()

    // The channel is exposed as a flow to expose a read-only interface
    val eventFlow = eventChannel.receiveAsFlow()

    // The entry point for UI actions to be handled by the ViewModel
    fun onAction(action: Action) {
        when (action) {
            is Action.OnNextClicked -&gt; eventChannel.trySend(UiEvent.NavigateToNext)
            is Action.OnTextChanged -&gt; state = state.copy(text = action.text)
            is Action.Save -&gt; repository.save(state.text)
        }
    }
}
</code></pre>
<h4 is-upgraded><strong>Constructor</strong></h4>
<ul>
<li>Repositories are injected into the <code>ViewModel</code> via Koin.</li>
<li><code>savedStateHandle</code>: An instance of <code>SavedStateHandle</code> is injected via Koin, allowing for the preservation of UI state during configuration changes.</li>
</ul>
<h4 is-upgraded><strong>private val args = savedStateHandle.navArgs</strong>()</h4>
<ul>
<li>This code snippet extracts navigation arguments from the <code>SavedStateHandle</code> to facilitate data exchange between screens during navigation.</li>
</ul>
<h4 is-upgraded><strong>var state by mutableStateOf(UiState())</strong></h4>
<ul>
<li>This variable is the single source of truth for the current UI state.</li>
<li>It is read-only for external sources, ensuring data consistency and reducing bugs.</li>
</ul>
<h4 is-upgraded><strong>private val eventChannel = Channel</strong>()</h4>
<ul>
<li>An event channel for sending UI events.</li>
<li>Exposes <code>eventFlow</code> to collect navigation events triggered by the ViewModel.</li>
</ul>
<h4 is-upgraded><strong>fun onAction(action: Action)</strong></h4>
<ul>
<li>Handles UI actions triggered by <strong>user interactions</strong>.</li>
<li>Updates the UI state as necessary.</li>
<li>Communicates changes to the Data layer when needed.</li>
<li>Sends <strong>UI events</strong> through the event channel.</li>
</ul>
<h3 is-upgraded>10.3.3 UiState.kt</h3>
<pre><code language="language-kotlin" class="language-kotlin">data class UiState(
    val text: String = &#34;&#34;,
    val isLoading: Boolean = false,
    val error: String = &#34;&#34;,
)
</code></pre>
<ul>
<li><code>UiState</code> represents the current and immutable state of the screen.</li>
<li><strong>Immutability</strong> is crucial for ensuring the <strong>reliability and predictability</strong> of the Compose composition process.</li>
<li>When you need to update the state, create a new state instance based on the current one rather than modifying the fields directly.</li>
</ul>
<h3 is-upgraded>10.3.4 UiEvent.kt</h3>
<pre><code language="language-kotlin" class="language-kotlin">sealed class UiEvent {
    object NavigateToNext : UiEvent()
    data class ShowDialog(val message: String) : UiEvent()
}
</code></pre>
<ul>
<li><code>UiEvent</code> represents various types of events that need to be handled at the View layer.</li>
<li>These events are often used to trigger navigations, animations, or display dialogs.</li>
<li>Fired by the ViewModel and handled by the UI.</li>
</ul>
<h3 is-upgraded>10.3.5 Action.kt</h3>
<pre><code language="language-kotlin" class="language-kotlin">sealed class Action {
    object OnNextClicked : Action()
    data class OnTextChanged(val text: String) : Action()
    object Save : Action()
}
</code></pre>
<ul>
<li><code>Action</code> represents user-initiated actions from the UI layer.</li>
<li>These actions are fired by the UI and handled by the ViewModel.</li>
</ul>
<h3 is-upgraded>10.3.6 NavArgs.kt</h3>
<pre><code language="language-kotlin" class="language-kotlin">data class NavArgs(
    val id: String = &#34;-1&#34;
)
</code></pre>
<ul>
<li><code>NavArgs</code> is a typed class that holds data passed between screens during navigation.</li>
<li>This data can be extracted from the <code>SavedStateHandle</code> within the ViewModel.</li>
</ul>
<h2 is-upgraded>10.4 Screen implementation</h2>
<p>Time to create the login screen! 🎉</p>
<h3 is-upgraded>10.4.1 Create the screen</h3>
<p>You should be able to create the screen yourself now. If you need help, you can always look at the previous screens and components. Make sure you create a new package called <strong>login</strong> in the <strong>onboarding</strong> package. The full path should be <strong>com.wiselab.«name».feature.onboarding.login</strong>.</p>
<h3 is-upgraded>10.4.2 Create the ViewModel</h3>
<p>Create a new Kotlin file called <strong>LoginViewModel</strong> in the <strong>login</strong> package.</p>
<pre><code language="language-kotlin" class="language-kotlin">class LoginViewModel : BaseViewModel()
</code></pre>
<ul>
<li>We extend the <strong>BaseViewModel</strong>. This is a class that we created to make it easier to create ViewModels. It contains some boilerplate code that we don&#39;t want to write every time we create a new ViewModel.</li>
</ul>
<h3 is-upgraded>10.4.3 Create the UiState</h3>
<p>Create a new Kotlin file called <strong>LoginUiState</strong> in the <strong>login</strong> package. Here you place the data that is needed to draw the screen. This is the data that is passed from the ViewModel to the View.</p>
<pre><code language="language-kotlin" class="language-kotlin">data class LoginUiState (
    val email: String = &#34;&#34;,
    val password: String = &#34;&#34;,
    val isPasswordVisible:Boolean = false
)
</code></pre>
<ul>
<li>Add this state to the <strong>LoginViewModel</strong>:</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">class LoginViewModel : BaseViewModel() {

    var state by mutableStateOf(LoginUiState())
        private set
}
</code></pre>
<h3 is-upgraded>10.4.4 Create the UiAction</h3>
<p>Create a new Kotlin file called <strong>LoginUiAction</strong> in the <strong>login</strong> package. Here you place the actions that can be triggered from the View. This is the data that is passed from the View to the ViewModel.</p>
<pre><code language="language-kotlin" class="language-kotlin">sealed class LoginUiAction {
    data object OnLoginClicked : LoginUiAction()
    data object OnRegisterClicked : LoginUiAction()
    data object OnForgotPasswordClicked : LoginUiAction()
    data object OnPasswordVisibilityClicked : LoginUiAction()
    data class OnEmailChanged(val email: String) : LoginUiAction()
    data class OnPasswordChanged(val password: String) : LoginUiAction()
}
</code></pre>
<p>A <strong>sealed class</strong> is a class that can only be <strong>extended in the same file</strong>. This means that we can only use these actions in the Login screen.</p>
<ul>
<li>Add this action to the <strong>LoginViewModel</strong>:</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">class LoginViewModel : BaseViewModel() {

    var state by mutableStateOf(LoginUiState())
        private set

    fun onAction(action: LoginUiAction) {
        when (action) {
            is LoginUiAction.OnLoginClicked -&gt; {}
            is LoginUiAction.OnRegisterClicked -&gt; {}
            is LoginUiAction.OnForgotPasswordClicked -&gt; {}  
            is LoginUiAction.OnPasswordVisibilityClicked -&gt; {}
            is LoginUiAction.OnEmailChanged -&gt; state = state.copy(email = action.value)
            is LoginUiAction.OnPasswordChanged -&gt; {}
        }
    }
}
</code></pre>
<p>The <code>onEmailChanged</code> action is given as an example. The other actions you have to fill in yourself in a couple of moments.</p>
<h3 is-upgraded>10.4.5 Implement in the Layout</h3>
<p>Before we can use the viewModel in the Layout, we need to add it to the app module. Open the <strong>appModule.kt</strong> file in the <strong>di</strong> package. Add the following code to the file:</p>
<pre><code language="language-kotlin" class="language-kotlin">val appModule = module {
    viewModel { LoginViewModel() }
}
</code></pre>
<ul>
<li>This way we can inject the viewModel in the Layout. Open the <strong>LoginScreen</strong> file and add the <code>viewModel: LoginViewModel = koinViewModel()</code> parameter to the <strong>Screen</strong> composable function.</li>
<li>In the layout composable add 2 parameters:<ul>
<li><code>state: LoginUiState</code></li>
<li><code>onAction: (LoginUiAction) -> Unit = {}</code></li>
</ul>
</li>
<li>In the screen composable add the following code:</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">@Composable
@Destination
@OnboardingNavGraph
fun LoginScreen(
    viewModel: LoginViewModel = koinViewModel()
) {
    LoginLayout(
      state = viewModel.state,
      onAction = viewModel::onAction
  )
}
</code></pre>
<ul>
<li>Now you can trigger the onEmailChanged action in the <strong>LoginLayout</strong> composable. Add this to your <code>EditText</code> composable: <code>onInputChange = { onAction(LoginUiAction.EmailChanged(it)) }</code></li>
<li>Do the same for the other password and passwordVisibility action. You can use the <code>onAction</code> function to trigger the actions in the ViewModel.</li>
<li>Hint: For the <strong>passwordVisibility</strong> you can check the <code>onClickIcon</code> parameter of the <code>EditText</code> composable.</li>
</ul>
<h3 is-upgraded>10.4.6 Events</h3>
<p>Now we need to add the events to the ViewModel.</p>
<ul>
<li>First create a new Kotlin file called <strong>LoginUiEvent</strong> in the <strong>login</strong> package.</li>
<li>Add the following code to the file:</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">sealed class LoginUiEvent {
    data object Back : LoginUiEvent()
    data object NavigateToRegister : LoginUiEvent()
    data object NavigateToForgotPassword : LoginUiEvent()
}
</code></pre>
<ul>
<li>We will use the <code>eventChannel</code> for this. Add the following code to the <strong>LoginViewModel</strong>:</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">class LoginViewModel : BaseViewModel() {

    var state by mutableStateOf(LoginUiState())
        private set

    private val eventChannel = Channel&lt;LoginUiEvent&gt;()
    val eventFlow = eventChannel.receiveAsFlow()

    fun onAction(action: LoginUiAction) {
        when (action) {
            is LoginUiAction.OnLoginClicked -&gt; {}
            is LoginUiAction.OnRegisterClicked -&gt; eventChannel.trySend(LoginUiEvent.NavigateToRegister)
            is LoginUiAction.OnForgotPasswordClicked -&gt; eventChannel.trySend(LoginUiEvent.NavigateToForgotPassword)
            is LoginUiAction.OnPasswordVisibilityClicked -&gt; {}
            is LoginUiAction.OnEmailChanged -&gt; state = state.copy(email = action.value)
            is LoginUiAction.OnPasswordChanged -&gt; {}
        }
    }
}
</code></pre>
<ul>
<li>Now we can use the <code>eventFlow</code> in the <strong>LoginScreen</strong> composable. Add the following code to the <strong>LoginScreen</strong> composable:</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">@Composable
@Destination
@OnboardingNavGraph
fun LoginScreen(
    navController: NavController,
    viewModel: LoginViewModel = koinViewModel()
) {
    LoginLayout(
        state = viewModel.state,
        onAction = viewModel::onAction
    )

    LaunchedEffect(viewModel) {
        viewModel.eventFlow.collect { event: LoginUiEvent -&gt;
            when (event) {
                is LoginUiEvent.Back -&gt; navController.popBackStack()
                is LoginUiEvent.NavigateToRegister -&gt; {}    //navController.navigate(RegisterScreenDestination) as example when the RegisterScreen is created
                is LoginUiEvent.NavigateToForgotPassword -&gt; {}
            }
        }
    }
}
</code></pre>
<p>Now you&#39;re set to add <strong>actions</strong> and <strong>events</strong> to your <code>LandingScreen</code> composable to fix the navigation. Don&#39;t forget to commit and push your changes. Create a pull request so your code can be reviewed! 🙌🏻</p>


      </google-codelab-step>
    
      <google-codelab-step label="Start Networking" duration="0">
        <p>Let&#39;s start adding some data. The Api Documentation can be found <a href="https://onboarding-todo-api.development.appwi.se/api/v1/docs/" target="_blank">here</a>. username: <code>appwise</code> password: <code>password</code></p>
<p>This is the endpoint that will be used: <code>https://onboarding-todo-api.development.appwi.se</code></p>
<p>We use <a href="https://developer.android.com/jetpack/androidx/releases/room" target="_blank">Room</a> for our local database. Room is an abstraction layer over SQLite. It makes it easier to work with SQLite. We use <a href="https://square.github.io/retrofit/" target="_blank">Retrofit</a> for our network calls. Retrofit is a type-safe HTTP client for Android and Java.</p>
<h2 is-upgraded>11.1 Setup Networking</h2>
<h3 is-upgraded>11.1.1 Init Database</h3>
<p>Create a new package called <strong>com.wiselab.«name».data</strong>. This is where we will put all our data related classes. In this package create a new package called <strong>com.wiselab.«name».data.database</strong>.</p>
<ul>
<li>Create a new class called <strong>AppDatabase</strong> in the <strong>database</strong> package. This class will be used to create our local database. Add the following code to the <strong>Database</strong> class:</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">@Database(
    entities = [],
    version = 1,
    exportSchema = false
)
abstract class AppDatabase : RoomDatabase() {

    companion object {
        const val DATABASE_NAME = &#34;todoApp.db&#34;
    }
}
</code></pre>
<h3 is-upgraded>11.1.3 Add product flavours</h3>
<ul>
<li>Open the <strong>build.gradle</strong> file of the <strong>app</strong> module.</li>
<li>Add <code>buildConfig = true</code> to the <strong>buildFeatures</strong> block</li>
<li>Add the following code to the <strong>android</strong> block:</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">flavorDimensions += &#34;env&#34;
productFlavors {
    create(&#34;dev&#34;) {
        buildConfigField(&#34;String&#34;, &#34;API_HOST&#34;, &#34;\&#34;https://onboarding-todo-api.development.appwi.se/\&#34;&#34;)
        buildConfigField(&#34;String&#34;, &#34;API_CLIENT_ID&#34;, &#34;\&#34;\&#34;&#34;)
        buildConfigField(&#34;String&#34;, &#34;API_CLIENT_SECRET&#34;, &#34;\&#34;\&#34;&#34;)

        dimension = &#34;env&#34;
        applicationIdSuffix = &#34;.dev&#34;
        versionNameSuffix = &#34;-dev&#34;
    }
}
</code></pre>
<ul>
<li>Client ID: <code>bdba526c-31b3-4740-a4e6-bfbaf96ec62e</code></li>
<li>Client Secret: <code>55d5f96e-eb16-4e98-8822-27cba3474e01</code></li>
</ul>
<p>The <strong>product flavours</strong> are used to create different versions of the app. We will use this to create a development version of the app. The development version will use the development API. In production apps we also include versions for staging and production. This way we can test the app on different environments. Make sure to <strong>build</strong> the project after adding the product flavours. This way the <strong>BuildConfig</strong> will be generated. It is possible that the <strong>wrong Buildconfig is automatically imported</strong>. <strong>Remove</strong> this import.</p>
<h3 is-upgraded>11.1.4 Initialise the core Networking module</h3>
<ul>
<li>In the app class, add a new function called <code>initNetworking()</code>:</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">private fun initNetworking() {
    Networking.Builder(this)
        .setPackageName(packageName)
        .setAppName(getString(R.string.app_name))
        .setClientIdValue(BuildConfig.API_CLIENT_ID)
        .setClientSecretValue(BuildConfig.API_CLIENT_SECRET)
        .setApiVersion(&#34;1&#34;).apply {
            if (isProxymanEnabled()) {
                registerProxymanService(context = this@App)
            }
        }.build()
}
</code></pre>
<p>This is where we initialise the Networking module. We use the <code>Networking.Builder</code> to create a new instance of the <code>Networking</code> class. Call this function from the <code>onCreate()</code> function of the app class.</p>
<h2 is-upgraded>11.2 Create the RestClients</h2>
<ul>
<li>Create a new package called <strong>networking</strong> like this: <strong>com.wiselab.«name».networking</strong></li>
<li>In this package create 2 new classes called <strong>ProtectedClient</strong> and <strong>UnProtectedClient</strong>.</li>
<li>For now create them like this:</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">class ProtectedClient(private val unprotectedClient: UnprotectedClient) : BaseRestClient() { 
    override val protectedClient = true
    override fun getBaseUrl() = BuildConfig.API_HOST
    override fun enableProxyManInterceptor() = true
}
</code></pre>
<pre><code language="language-kotlin" class="language-kotlin">class UnProtectedClient : BaseRestClient() {
    override val protectedClient = false
    override fun getBaseUrl() = BuildConfig.API_HOST
    override fun enableProxyManInterceptor() = true
}
</code></pre>
<h2 is-upgraded>11.3 ApiManagerService</h2>
<p>We are going to create the <strong>service</strong> that will be used for api token management. This service will be used to get the api token and refresh it when it&#39;s expired.</p>
<ul>
<li>Create a new package called <strong>service</strong> in the <strong>networking</strong> package like this: <strong>com.wiselab.«name».networking.services</strong></li>
<li>In this package create a new interface called <strong>AuthService</strong>:</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">interface AuthService : BaseService {

    //OAuth token
    @FormUrlEncoded
    @POST(&#34;/api/oauth/token&#34;)
    fun loginWithPassword(
        @Field(NetworkConstants.KEY_GRANT_TYPE) grantType: String,
        @Field(NetworkConstants.KEY_CLIENT_ID) clientId: String,
        @Field(NetworkConstants.KEY_CLIENT_SECRET) client_secret: String,
        @Field(&#34;username&#34;) username: String,
        @Field(&#34;password&#34;) code: String,
        @Field(&#34;scope&#34;) scopeRead: String = &#34;read write&#34;
    ): Call&lt;AccessToken&gt;

    //OAuth Refresh Token
    @FormUrlEncoded
    @POST(&#34;/api/oauth/token&#34;)
    fun refreshToken(
        @Field(NetworkConstants.KEY_GRANT_TYPE) grantType: String,
        @Field(NetworkConstants.KEY_CLIENT_ID) clientId: String,
        @Field(NetworkConstants.KEY_CLIENT_SECRET) client_secret: String,
        @Field(NetworkConstants.FIELD_IDENTIFIER_REFRESH_TOKEN) refreshToken: String
    ): Call&lt;AccessToken&gt;
}
</code></pre>
<p>Here we define the endpoints that we will use to get the api token and refresh it when it&#39;s expired. The fields that are used in the endpoints are defined in the <strong>NetworkConstants</strong> class.</p>
<h2 is-upgraded>11.4 Repository</h2>
<p>We are going to create the <strong>repository</strong> that will be used to get the api token and refresh it when it&#39;s expired.</p>
<ul>
<li>Create a new package called <strong>repository</strong> in the <strong>data</strong> package like this: <strong>com.wiselab.«name».data.repository</strong></li>
<li>In this package create a new <strong>package</strong> called <strong>authRepo</strong>:</li>
<li>In this package create a new interface called <strong>AuthRepo</strong>:</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">interface AuthRepo : BaseRepository {

    suspend fun login(email: String, password: String)
}
</code></pre>
<p>We create this interface so we can use it in the <strong>AuthRepoImpl</strong> class. This way we can use <strong>dependency injection</strong> to inject the <strong>AuthRepo</strong> interface where needed. You also see we make use of a suspend function. This is because we will make <strong>asynchronous</strong> calls to the api. We will use <strong>coroutines</strong> to make these calls. <a href="https://developer.android.com/kotlin/coroutines" target="_blank">Coroutines</a> are a Kotlin feature that convert async callbacks for long-running tasks, such as database or network access, into sequential code. It&#39;s a bit more advanced so we won&#39;t go into detail here. You can read more about it in the documentation.</p>
<ul>
<li>In the <strong>authRepo</strong> package create a new class called <strong>AuthRepoImpl</strong>:</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">class AuthRepoImpl(
    private val db: AppDatabase,
    private val protectedClient: ProtectedClient,
    private val unprotectedClient: UnprotectedClient
) : AuthRepo {

    override suspend fun login(email: String, password: String) {
        val accessToken = doCall(
            unprotectedClient.getService&lt;AuthService&gt;().loginWithPassword(
                &#34;password&#34;,
                Networking.getClientIdValue(),
                Networking.getClientSecretValue(),
                email,
                password
            )
        )

        Networking.saveAccessToken(accessToken)
    }
}
</code></pre>
<p>As parameters we pass the <strong>AppDatabase</strong>, <strong>ProtectedClient</strong> and <strong>UnprotectedClient</strong>. We use the <strong>UnprotectedClient</strong> to get the <strong>AuthService</strong> service. We use this service to get the api token. We use the <strong>ProtectedClient</strong> to save the api token in the <strong>Networking</strong> class. Make sure to take a look at the <code>doCall()</code> function that is used to make the api call. This function is defined in the <strong>BaseRepository</strong> class.</p>
<h2 is-upgraded>11.5 Hawk</h2>
<p>Hawk is secure, simple key-value storage for Android. It&#39;s encrypted and it&#39;s easy to use. We will use it to store some values.</p>
<ul>
<li>Create a package <strong>Util</strong> like this: <strong>com.wiselab.«name».util</strong></li>
<li>In this package create a new <strong>package</strong> called <strong>managers</strong></li>
<li>In this package create a new object called <strong>HawkManager</strong>:</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">object HawkManager {
    private const val CURRENT_USER = &#34;current_user&#34;
    
    var currentUserId: String by HawkValueDelegate(CURRENT_USER, defaultValue = &#34;&#34;)
}
</code></pre>
<p>Here we define the keys that we will use to store values in Hawk. We also define the default values for the values that we store in Hawk.</p>
<h2 is-upgraded>11.6 Create a first model</h2>
<p>Let&#39;s implement the <code>userInfo</code> endpoint. This endpoint will return the user info of the logged in user.</p>
<ul>
<li>Create a new package called <strong>entity</strong> in the <strong>data</strong> package like this: <strong>com.wiselab.«name».data.entity</strong> Here we will store our entities. These are the objects that we will use to store the data that we get from the api.</li>
<li>Check the API documentation to see what data we get from the api. We will create a new data class called <strong>User</strong>:</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">import androidx.room.Entity
import androidx.room.PrimaryKey
import be.appwise.room.BaseEntity
import com.google.gson.annotations.SerializedName
import org.joda.time.DateTime

@Entity(tableName = User.USER_TABLE_NAME)
data class User(
    @PrimaryKey
    @SerializedName(&#34;uuid&#34;)
    override val id: String,
    val createdAt: DateTime? = DateTime(),
    val updatedAt: DateTime? = DateTime(),
    val email: String? = &#34;&#34;,
    val firstName: String? = &#34;&#34;,
    val lastName: String? = &#34;&#34;,
    val role: UserRole? = UserRole.USER
) : BaseEntity {
    companion object {
        const val USER_TABLE_NAME = &#34;user&#34;
    }
}
</code></pre>
<p>We will give the <code>user</code> class as an example. The entity annotation is used to tell Room that this is an entity.</p>
<ul>
<li>The <code>tableName</code> parameter is used to define the name of the table in the database.</li>
<li>The <code>id</code> parameter is used to define the primary key of the table.</li>
<li>The <code>BaseEntity</code> interface is used to make sure that all entities have an id.</li>
<li>Don&#39;t forget to create the <strong>UserRole</strong> enum class, all the options are visible in the documentation.</li>
</ul>
<p>Now we have created our first Entity. We will use this entity to store the data that we get from the api. But first add this entity to the <strong>AppDatabase</strong> class in the annotation:</p>
<pre><code language="language-kotlin" class="language-kotlin">@Database(
    entities = [
        User::class
    ],
    version = 1,
    exportSchema = false
) {}
</code></pre>
<ul>
<li>In the <strong>AuthService</strong> class add a new function called <code>userInfo()</code></li>
<li>This is a Get call with the endpoint specified in the annotation, it returns a <code>User</code> object:</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">@GET(&#34;/api/oauth/userinfo&#34;)
    fun userInfo(): Call&lt;User&gt;
</code></pre>
<ul>
<li>Add a new function to the AuthRepo interface called <code>userInfo()</code> and implement it in the <strong>AuthRepoImpl</strong> class:</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">override suspend fun userInfo() {
        doCall(protectedClient.getService&lt;AuthService&gt;().userInfo()).also {
            HawkManager.currentUserId = it.id
        }
    }
</code></pre>
<h2 is-upgraded>11.7 DAO</h2>
<p>A dao is used to access the database. We will create a dao for the <code>User</code> entity.</p>
<ul>
<li>Create a new package called <strong>dao</strong> in the <strong>data</strong> package like this: <strong>com.wiselab.«name».data.dao</strong></li>
<li>In this package create a new <strong>abstract</strong> class called <strong>UserDao</strong>:</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">import androidx.room.Dao
import be.appwise.room.BaseRoomDao
import com.wiselab.onboarding_compose.data.entity.User

@Dao
abstract class UserDao : BaseRoomDao&lt;User&gt;(User.USER_TABLE_NAME)
</code></pre>
<ul>
<li>Add this DAO to the <strong>AppDatabase</strong> class, it should look like this:</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">@Database(
    entities = [
        User::class
               ],
    version = 1,
    exportSchema = false
)
abstract class AppDatabase : RoomDatabase() {

    companion object {
        const val DATABASE_NAME = &#34;todoApp.db&#34;
    }
    
    abstract fun userDao(): UserDao
}
</code></pre>
<ul>
<li>Now we want to save our User data we get from the <code>userInfo()</code> call into our database. This is done by adding the <strong>insert</strong> line to the <code>userInfo()</code> call:</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">override suspend fun userInfo() {
        doCall(protectedClient.getService&lt;AuthService&gt;().userInfo()).also {
            HawkManager.currentUserId = it.id
            db.userDao().insert(it)
        }
    }
</code></pre>
<h2 is-upgraded>11.8 Adding login and register</h2>
<p>You already added the <code>login()</code> function to the <strong>AuthRepo</strong> interface. Add the <code>userInfo()</code> function to the login function like this:</p>
<pre><code language="language-kotlin" class="language-kotlin">override suspend fun login(email: String, password: String) {
        val accessToken = doCall(
            unprotectedClient.getService&lt;AuthService&gt;().loginWithPassword(
                &#34;password&#34;,
                Networking.getClientIdValue(),
                Networking.getClientSecretValue(),
                email,
                password
            )
        )

        Networking.saveAccessToken(accessToken)
        userInfo()
    }
</code></pre>
<p>This way we will get the user info stored in the database after we logged in.</p>
<ul>
<li>Navigate to your <code>LoginViewModel</code> and add the <code>authRepo</code> as a parameter to the constructor.</li>
<li>This will be injected so we need to add some code to the appModule:</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">val appModule = module {
    single {
        Room.databaseBuilder(
            App.instance,
            AppDatabase::class.java,
            AppDatabase.DATABASE_NAME
        )
            .fallbackToDestructiveMigration()
            .build()
    }
    
    single { UnprotectedClient() }
    single { ProtectedClient(get()) }
  
    single&lt;AuthRepo&gt; { AuthRepoImpl(get(), get(), get()) }
  
    viewModel { LoginViewModel() }
}
</code></pre>
<p>Let&#39;s explain what we are doing. We are creating singletons of the <code>AppDatabase</code>, <code>UnprotectedClient</code>, <code>ProtectedClient</code> and <code>AuthRepoImpl</code> classes. This is needed because we want to use the same instance of these classes everywhere in the app. We also want to inject the <code>AuthRepoImpl</code> class in the <code>LoginViewModel</code>.</p>
<ul>
<li>The <code>AuthRepo</code> has a dependency on the <code>AppDatabase</code>, <code>UnprotectedClient</code> and <code>ProtectedClient</code> classes. We use the <code>get()</code> function to get the instance of these classes.</li>
</ul>
<h3 is-upgraded>11.8.1 Login</h3>
<ul>
<li>In the <code>LoginViewModel</code> add a new function called <code>login()</code>:</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">fun login(email: String, password: String) = launchAndLoad { 
    authRepo.login(email, password)
}
</code></pre>
<p>This function can be called from the onAction of the <code>LoginViewModel</code> so we can use it in the <code>LoginScreen</code>. The launchAndLoad function is a function that is defined in the <code>BaseViewModel</code>. It&#39;s a function that is used to make asynchronous calls.</p>
<ul>
<li>We want to add an <strong>extra parameter</strong> to the login function for future purposes.</li>
<li>At this moment we don&#39;t know if the login call <strong>succeeds</strong>. A handy feature of coroutines is that the <strong>coroutine is cancelled</strong> when an exception is thrown.</li>
<li>Therefore we add the extra parameter <code>onSuccess</code> to the <code>login()</code> function. This is a function that will be called when the login call succeeds.</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">fun login(email: String, password: String, onSuccess: () -&gt; Unit) = launchAndLoad {
    authRepo.login(email, password)
    onSuccess()
}
</code></pre>
<p>This onSuccess function will be used to <strong>navigate</strong> to the main screen when the <strong>login call</strong> succeeds.</p>
<h3 is-upgraded>11.8.2 Register</h3>
<p>Let&#39;s create the register functionality. Start by adding a new service called <code>UserService</code> We do this to keep the calls separated like in the <strong>api documentation</strong>.</p>
<ul>
<li>Add this to your service:</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">@POST(&#34;api/v1/users&#34;)
fun register(
  @Body userRequest: UserRequest
): Call&lt;User&gt;
</code></pre>
<link rel="stylesheet" href="css/style.css">
<p>This is a <strong>@POST</strong> call with the endpoint specified in the annotation, it returns a <code>User</code> object as visible in the <strong>documentation</strong>. The call expects a <strong>body</strong>, also visible in the documentation. You can see this is not the same object as a <code>User</code> object. Therefore we create a new <strong>request</strong> object called <code>UserRequest</code>:</p>
<ul>
<li>Create a new package called <strong>model</strong> in the <strong>networking</strong> package like this: <strong>com.wiselab.«name».networking.model</strong></li>
<li>In this package create a new package called <strong>request</strong></li>
<li>In this package create a new data class called <strong>UserRequest</strong> with the data that is necessary for the register call</li>
</ul>
<p><strong>Side note</strong>: It&#39;s possible you get objects from the api that you <strong>don&#39;t</strong> want as an entity. Something that has to be <strong>mapped</strong> to an existing entity for example. To solve this we create a package called <strong>response</strong> in the <strong>model</strong> package. Here we create the objects that we get from the api. We use these objects to <strong>map</strong> to our entities.</p>
<p><strong>New Repo</strong></p>
<ul>
<li>Create a new package called <strong>userRepo</strong> in the <strong>repository</strong> package like this: <strong>com.wiselab.«name».data.repository.userRepo</strong></li>
<li>You have the knowledge to create this repo with the <strong>register call</strong> yourself. If you need help, you can check the <strong>authRepo</strong>.</li>
<li>Don&#39;t forget to update the appModule with the new repo.</li>
<li>Make sure to commit and push your code. You may want to create a pull request for this.</li>
</ul>
<h3 is-upgraded>11.8.3 Hint</h3>
<ul>
<li>The cleanest way to create this userRequest is to get it in the state. Use this as an example:</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">data class RegisterUiState(
    val email: String = &#34;&#34;,
    val password: String = &#34;&#34;,
    val firstName: String = &#34;&#34;,
    val lastName: String = &#34;&#34;,
) {
    val userRequest: UserRequest
        get() = UserRequest(email, password, firstName, lastName)
}
</code></pre>
<p>Now you are fully set up to create the rest of the application yourself. Use this CodeLab as a reference if you need help. Don&#39;t be afraid to ask for help if you need it. Good luck! 🚀</p>


      </google-codelab-step>
    
      <google-codelab-step label="Recap" duration="0">
        

      </google-codelab-step>
    
  </google-codelab>

  <script src="https://storage.googleapis.com/claat-public/native-shim.js"></script>
  <script src="https://storage.googleapis.com/claat-public/custom-elements.min.js"></script>
  <script src="https://storage.googleapis.com/claat-public/prettify.js"></script>
  <script src="https://storage.googleapis.com/claat-public/codelab-elements.js"></script>
  <script src="//support.google.com/inapp/api.js"></script>

<link rel="stylesheet" href="css/style.css">
</body>
</html>
